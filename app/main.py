#!/usr/bin/env python3

import jwt
import uvicorn
import jsonschema
from os import getenv
from fastapi import FastAPI, Depends, HTTPException, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2AuthorizationCodeBearer
from motor.motor_asyncio import AsyncIOMotorClient
from aio_pika import connect_robust

from .rest import Rest
from .pubsub import PubSub
from .schema import socket_schema

app = FastAPI()

# Allow cross-origin requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"]
)

# Token authorization (generated by auth container)
secret = getenv('AUTH_SECRET')
oauth2_scheme = OAuth2AuthorizationCodeBearer(
        authorizationUrl = "auth",
        tokenUrl = "token",
        # Allow unauthorized access
        auto_error = False)

def token_to_owner_id(token: str = Depends(oauth2_scheme)):
    # In case no authorization was provided
    if not token: return token

    # Assert that the token is valid
    try:
        token = jwt.decode(token, secret, algorithms=["HS256"])
    except:
        raise HTTPException(status_code=400, detail="malformed token")
    if not token["type"] == "token":
        raise HTTPException(status_code=400, detail="invalid code type.")

    return token["owner_id"]

@app.on_event("startup")
async def startup():
    # Initialize the database
    client = AsyncIOMotorClient('mongo')
    db = client.graffiti.objects

    # Create indexes if they don't already exist
    await db.create_index('owner_id')
    await db.create_index('object._id')
    await db.create_index('object._timestamp')
    await db.create_index('object.$**')
    await db.create_index('contexts.$**')

    # Initialize the message queue
    while True:
        try:
            mq = await connect_robust("amqp://rabbit")
            break
        except:
            print("Waiting for message queue to come online...")
            await asyncio.sleep(1)

    # Initialize rest and 
    app.rest   = Rest  (db, mq)
    app.pubsub = PubSub(db, mq)

@app.websocket("/")
async def query_socket(ws: WebSocket, owner_id: str = Depends(token_to_owner_id)):
    await ws.accept()

    # Register with the pub/sub manager
    async with pubsub.register(ws) as socket_id:

        # Pre-compute this owner's schema
        schema = socket_schema(owner_id)

        # Send messages back and forth
        while True:
            try:
                msg = await ws.receive_msg()
                await reply(ws, msg, schema, socket_id, owner_id)
            except:
                break

async def reply(ws, msg, schema, socket_id, owner_id):

    try:
        # Make sure the message is formatted properly
        jsonschema.validate(msg, schema)

        # Initialize the output
        output = {
            'type': 'success',
            # echo the incoming message ID
            'messageID': msg['messageID']
        }

        if msg['type'] == 'update':
            object_id = await rest.update(msg['object'], owner_id)
            output['objectID'] = object_id

        elif msg['type'] == 'delete':
            await rest.delete(msg['objectID'], owner_id)

        elif msg['type'] == 'subscribe':
            await pubsub.subscribe(socket_id, msg['query'], owner_id)
            output['queryHash'] = query_hash

        elif msg['type'] == 'unsubscribe':
            await pubsub.unsubscribe(socket_id, msg['queryHash'])

    except Exception as e:
        await ws.send_json({
            'type': 'error',
            'detail': str(e)
        })

    else:
        await ws.send_json(output)

if __name__ == "__main__":
    args = {}
    if getenv('DEBUG') == 'true':
        args['reload'] = True
    uvicorn.run('app.main:app', host='0.0.0.0', **args)
