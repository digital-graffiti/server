#!/usr/bin/env python3

import jwt
import time
import uvicorn
import jsonschema
from os import getenv
from fastapi import FastAPI, Depends, HTTPException, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2AuthorizationCodeBearer
from motor.motor_asyncio import AsyncIOMotorClient
import aioredis

from .rest import Rest
from .pubsub import PubSub
from .schema import socket_schema

app = FastAPI()

# Allow cross-origin requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"]
)

# Token authorization (generated by auth container)
secret = getenv('AUTH_SECRET')
def token_to_owner_id(token: str|None=None):
    # In case no authorization was provided
    if not token: return token

    # Assert that the token is valid
    try:
        token = jwt.decode(token, secret, algorithms=["HS256"])
    except:
        raise HTTPException(status_code=400, detail="malformed token")
    if not token["type"] == "token":
        raise HTTPException(status_code=400, detail="invalid code type.")

    return token["owner_id"]

@app.on_event("startup")
async def startup():
    # Initialize the database
    client = AsyncIOMotorClient('mongo')
    db = client.graffiti.objects

    # Create indexes if they don't already exist
    await db.create_index('_owner_id')
    await db.create_index('_object._id')
    await db.create_index('_object._timestamp')
    await db.create_index('_object._tombstone')
    await db.create_index('_object.$**')
    await db.create_index('_contexts.$**')

    # Initialize the pubsub/locking system
    redis = aioredis.from_url("redis://redis", decode_responses=True)

    # Initialize database interfaces
    app.rest   = Rest  (db, redis)
    app.pubsub = PubSub(db, redis)

@app.websocket("/")
async def query_socket(ws: WebSocket, owner_id: str|None=Depends(token_to_owner_id)):
    await ws.accept()

    # Register with the pub/sub manager
    async with app.pubsub.register(ws) as socket_id:

        # Pre-compute this owner's schema
        validator = jsonschema.Draft7Validator(socket_schema(owner_id))

        # Send messages back and forth
        while True:
            try:
                msg = await ws.receive_json()
                await reply(ws, msg, validator, socket_id, owner_id)
            except:
                break

async def reply(ws, msg, validator, socket_id, owner_id):
    # Initialize the output
    output = {}

    try:
        # Make sure the message is formatted properly
        validator.validate(msg)

        # echo the incoming message ID
        output['messageID'] = msg['messageID']

        if msg['type'] == 'update':
            object_id = await app.rest.update(msg['object'], owner_id)
            output['objectID'] = object_id

        elif msg['type'] == 'delete':
            await app.rest.delete(msg['objectID'], owner_id)

        elif msg['type'] == 'subscribe':
            await app.pubsub.subscribe(socket_id, msg['query'], owner_id)
            output['queryHash'] = query_hash

        elif msg['type'] == 'unsubscribe':
            await app.pubsub.unsubscribe(socket_id, msg['queryHash'])

    except jsonschema.exceptions.ValidationError as e:
        output['type'] = 'validationError'
        output['detail'] = str(e)
        await ws.send_json(output)

    except Exception as e:
        output['type'] = 'error'
        output['detail'] = str(e)
        await ws.send_json(output)

    else:
        output['type'] = 'success'
        await ws.send_json(output)

if __name__ == "__main__":
    args = {}
    if getenv('DEBUG') == 'true':
        args['reload'] = True
    uvicorn.run('app.main:app', host='0.0.0.0', **args)
